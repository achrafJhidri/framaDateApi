package com.example.framadate.service;


import com.example.framadate.entity.Comment;
import com.example.framadate.entity.Survey;
import com.example.framadate.entity.User;

import com.example.framadate.entity.Vote;
import com.example.framadate.mapper.SurveyMapper;
import com.example.framadate.model.CommentDto;
import com.example.framadate.model.SurveyDto;

import com.example.framadate.model.VoteDto;
import com.example.framadate.repository.SurveyRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.val;
import org.apache.tomcat.util.json.JSONParser;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class SurveyService {

    private final SurveyRepository surveyRepository;
    private final SurveyMapper surveyMapper;
    private final UserService userService;
    private final CommentService commentService;
    private final DateService dateService;
    private final VoteService voteService;



    public SurveyService(SurveyRepository surveyRepository, SurveyMapper surveyMapper, UserService userService
            , CommentService commentService, DateService dateService, VoteService voteService) {
        this.surveyRepository = surveyRepository;
        this.surveyMapper = surveyMapper;
        this.userService = userService;
        this.commentService = commentService;
        this.dateService = dateService;
        this.voteService = voteService;
    }

    public List<SurveyDto> findAllSurveys(){
        List<Survey> surveys = surveyRepository.findAll();
        return  surveys.stream().map(surveyMapper::toDto).collect(Collectors.toList());
    }
    public SurveyDto findOneSurvey(Long id){
        Optional<Survey> survey = surveyRepository.findById(id) ;
        return survey.map(surveyMapper::toDto).orElse(null);
    }
    public SurveyDto createSurvey(SurveyDto surveyDto) {
        Survey survey = new Survey();
        surveyMapper.toEntity(survey,surveyDto);
        survey = surveyRepository.saveAndFlush(survey);//will generate a new id
        surveyDto.setId(survey.getId());

       return surveyDto;
    }
    public SurveyDto updateSurvey(Long id, SurveyDto surveyDto) {
        Optional<Survey> surveyOptional = surveyRepository.findById(id);
        if (surveyOptional.isEmpty()) { //Not Found in db
          return null ;
        }
        Survey survey  = surveyOptional.get(); // this isn't redundant
                                               // it's useful when you want to update juste one field
                                               // so all the others must remain as before
        surveyMapper.toEntity(survey , surveyDto);
        surveyRepository.saveAndFlush(survey);
        return surveyMapper.toDto(survey);
    }

    public List<CommentDto> findAllComments(Long id){
        Optional<Survey> survey = surveyRepository.findById(id) ;
        return survey.map(value -> value.getComments()
                .stream().map(commentService::toDto).collect(Collectors.toList())).orElse(new ArrayList<>());
    }
    public CommentDto comment(Long surveyId, CommentDto commentDto) {
        Optional<Survey> surveyOptional = surveyRepository.findById(surveyId);
        if (surveyOptional.isEmpty()) { //Not Found in db
            return null ;
        }

        User user = userService.findUserById(commentDto.getUserId());
        if ( user == null )
            return null ;

        //TODO should be removed to commentService
        Comment commentEntity = new Comment();
        commentEntity.setComment(commentDto.getComment());
        commentEntity.setCreationDate(new Date());
        commentEntity.setLastUpdate(new Date());
        commentEntity.setSurvey(surveyOptional.get());
        commentEntity.setUser(user);
        commentEntity = commentService.save(commentEntity);// the id is autogenerated here


        return commentService.toDto(commentEntity);
    }
    public CommentDto updateComment( CommentDto commentDto, Long commentId) {
        return commentService.updateComment(commentDto,commentId);
    }
    public String deleteComment(Long commentId) {
        return commentService.deleteComment(commentId);
    }


    public List <Date> getAllDates(Long surveyId) {
        Optional<Survey> survey = surveyRepository.findById(surveyId) ;
        return survey.map(value -> value.getDates()
                .stream().map(com.example.framadate.entity.Date::getDate).collect(Collectors.toList())).orElse(new ArrayList<>());
    }
    public List<Date> addDates(Long id, Set<Date> dates) {
        Optional<Survey> survey = surveyRepository.findById(id) ;
        if (survey.isPresent()) {

            Set<com.example.framadate.entity.Date> dateEntities =  dateService.getOrCreateDates(dates);
            survey.get().addDates(dateEntities);

            surveyRepository.saveAndFlush(survey.get());

            return dateService.toDtos(dateEntities);
        }
        return new ArrayList<>();
    }
    public Survey deleteDate(Long surveyId, Date dateId) {
        Optional<Survey> survey = surveyRepository.findById(surveyId) ;
        if (survey.isPresent()) {
            boolean retrieved = survey.get().getDates().removeIf(date -> date.getDate().compareTo(dateId)==0);
            if (retrieved ) {
                surveyRepository.saveAndFlush(survey.get());
                return survey.get();
            }
        }
        return  null ;
    }

    public VoteDto vote(Long surveyId, VoteDto voteDto)  {

        Optional<Survey> surveyOptional = surveyRepository.findById(surveyId);
        if (surveyOptional.isEmpty()) { //Not Found in db
            return null ;
        }
        voteDto.getVoteIdDto().setSurveyId(surveyId); //TODO remove when creating the adapted VoteDto


        User user = userService.findUserById(voteDto.getUserId());
        if (user == null)
            return null;

        val stream = surveyOptional.get().getDates().stream()
                .filter(date-> date.getDate().compareTo(voteDto.getDateId())==0); //even if it's a stream at most their will be 1date matching
        if(stream.count() > 0) {
            return voteService.vote(user,voteDto.getDateId(),surveyOptional.get(), voteDto);
        }
        return null;


    }

    public List<VoteDto> findAll(Long surveyId) {
        Optional<Survey> survey = surveyRepository.findById(surveyId) ;
        return survey.map(value -> value.getVotes()
                .stream().map(voteService::toDtos).collect(Collectors.toList())).orElse(new ArrayList<>());
    }
}
